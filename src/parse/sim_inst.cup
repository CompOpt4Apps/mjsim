package parse;

import java_cup.runtime.*;
import java.util.*;

import parse.TokenValue;

import machine.MachineState;

import instructions.*;

parser code {:

    protected static MachineState machine = null;//complete hack
    //hopefully it will work.

    public sim_inst(java_cup.runtime.Scanner lexer, MachineState machine)
    {
        this(lexer);
        this.machine = machine;
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        report_fatal_error("Fatal syntax error", cur_token);
    }
    
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        done_parsing();
        Symbol token = (Symbol)info;
        TokenValue tok = (TokenValue)token.value;
        throw new ParseException("Fatal parsing error", tok.line, tok.pos);
    }
    
    public void report_error(String message, Object info) {
        Symbol token = (Symbol)info;
        TokenValue tok = (TokenValue)token.value;
        System.err.println("[" + tok.line + "," + tok.pos + "] " 
                               + message + " at " + tok.toString() );
    }
:}

/* Symbols */
terminal EOL;
terminal ASSIGN, COMMA, LPARAN, RPARAN, AVR_HI, AVR_LO;
terminal TokenValue NUM, HEX, QSTRING;
terminal TokenValue DOT_FILE, DOT_GLOBAL, DOT_TEXT, DOT_TYPE, SIZE_TYPE, MINUS, DOT;
terminal TokenValue SP_L, SP_H;
terminal TokenValue REG, LABEL, GLOBAL, TYPE, ID;

non terminal TokenValue exp;
non terminal List<Instr> pgrm, instrs;
non terminal Instr instr;
non terminal header, eol; 

/* AVR Functions */
terminal AVR_PUSH, AVR_POP, AVR_IN, AVR_LD, AVR_LDI, AVR_ADD, AVR_ADC, AVR_CALL, AVR_RET, AVR_AND, AVR_EOR, AVR_JMP, AVR_NEG, AVR_OR, AVR_CP, AVR_SUB, AVR_BREQ, AVR_BRLO, AVR_BRLT, AVR_TST, AVR_MULS;

/* Grammar */
start with pgrm;

pgrm	::=	header instrs:s
		{:
			RESULT=s;
		:}
	;

header	::=	DOT_FILE QSTRING eol
		GLOBAL ASSIGN HEX eol
		SP_H ASSIGN HEX eol
		SP_L ASSIGN HEX eol
		GLOBAL ASSIGN exp eol
		GLOBAL ASSIGN exp eol
		DOT_GLOBAL ID eol
		DOT_GLOBAL ID eol
		DOT_TEXT eol
		DOT_GLOBAL ID eol
		DOT_TYPE ID COMMA TYPE eol
		LABEL eol
		AVR_PUSH REG eol
		AVR_PUSH REG eol
		AVR_IN REG COMMA SP_L eol
		AVR_IN REG COMMA SP_H eol
		AVR_CALL ID eol
		{:
		    RESULT=null;//empty state.
        :}
	;

instrs	::=	instr:t instrs:list
		{:
            list.add(0,t);
			RESULT=list;
		:}

        | /* epsilon */ 
        {:
            RESULT = new LinkedList<Instr>();
        :}
	;

eol     ::= eol EOL | EOL
		{: /*do nothing*/
		:}
		;

instr	::=	AVR_PUSH REG:r eol
		{:
			RESULT= new InstrPush(sim_inst.machine,Integer.parseInt(r.toString()));
		:}
	|	AVR_POP REG:r eol 
		{:
			RESULT= new InstrPop(sim_inst.machine,Integer.parseInt(r.toString()));
		:}
	|	AVR_IN REG:r COMMA SP_L eol 
		{:
			RESULT= new InstrIn(sim_inst.machine,Integer.parseInt(r.toString()),InstrInType.SPL);
		:}
	|	AVR_IN REG:r COMMA SP_H eol 
		{:
			RESULT= new InstrIn(sim_inst.machine,Integer.parseInt(r.toString()),InstrInType.SPH);
		:}
	|	AVR_LD eol 
		{:
			//RESULT= new InstrLD(sim_inst.machine);
		:}
		
	|	AVR_LDI REG:r COMMA AVR_LO LPARAN exp:e RPARAN eol 
		{:
			RESULT= new InstrLDI(sim_inst.machine,Integer.parseInt(r.toString()),Integer.parseInt(e.toString()));
		:}
	|	AVR_LDI REG:r COMMA AVR_HI LPARAN exp:e RPARAN eol 
		{:
			RESULT= new InstrLDI(sim_inst.machine,Integer.parseInt(r.toString()),Integer.parseInt(e.toString()));
		:}
	|	AVR_LDI REG:r COMMA exp:e eol 
		{:
			RESULT= new InstrLDI(sim_inst.machine,Integer.parseInt(r.toString()),Integer.parseInt(e.toString()));
		:}
	|	AVR_ADD REG:r1 COMMA REG:r2 eol 
		{:
			RESULT= new InstrAdd(sim_inst.machine,Integer.parseInt(r1.toString()),Integer.parseInt(r2.toString()));
		:}
	|	AVR_MULS REG:r1 COMMA REG:r2 eol 
		{:
			RESULT= new InstrMuls(sim_inst.machine,Integer.parseInt(r1.toString()),Integer.parseInt(r2.toString()));
		:}
	|	AVR_ADC REG:r1 COMMA REG:r2 eol 
		{:
			RESULT= new InstrAdc(sim_inst.machine,Integer.parseInt(r1.toString()),Integer.parseInt(r2.toString()));
		:}
	|	AVR_CALL ID:l eol
		{:
			RESULT= new InstrCall(sim_inst.machine,l.toString());
		:}
	|	AVR_RET eol
		{:
			RESULT= new InstrRet(sim_inst.machine);
		:}
	|	AVR_AND REG:r1 COMMA REG:r2 eol
		{:
			RESULT= new InstrAnd(sim_inst.machine,Integer.parseInt(r1.toString()),Integer.parseInt(r2.toString()));
		:}
	|	AVR_EOR REG:r1 COMMA REG:r2 eol 
		{:
			RESULT= new InstrEor(sim_inst.machine,Integer.parseInt(r1.toString()),Integer.parseInt(r2.toString()));
		:}
	|	AVR_JMP ID:l eol
		{:
			RESULT= new InstrJmp(sim_inst.machine,l.toString());
		:}
	|	AVR_NEG REG:r eol
		{:
			RESULT= new InstrNeg(sim_inst.machine,Integer.parseInt(r.toString()));
		:}
    |
        AVR_BREQ ID:l eol
        {:
            RESULT= new InstrBREQ(sim_inst.machine,l.toString()); 
        :}
    |
        AVR_BRLO ID:l eol
        {:
            RESULT= new InstrBRLO(sim_inst.machine,l.toString()); 
        :}
    |
        AVR_CP REG:r1 COMMA REG:r2 eol
        {:
            RESULT= new InstrCP(sim_inst.machine,Integer.parseInt(r1.toString()),Integer.parseInt(r2.toString()));
        :}
	|	AVR_OR REG:r1 COMMA REG:r2 eol
		{:
			RESULT= new InstrOr(sim_inst.machine,Integer.parseInt(r1.toString()),Integer.parseInt(r2.toString()));
		:}
	|	AVR_BRLT ID:l eol
		{:
			RESULT = new InstrBRLT(sim_inst.machine,l.toString());
		:}
	|	AVR_TST REG:r eol
		{:
			RESULT = new InstrTST(sim_inst.machine,Integer.parseInt(r.toString()));
		:}
	
	|	LABEL:l | LABEL:l eol
		{:
            //Edit the label a bit.
            String label = l.toString();
            label = label.substring(0,label.indexOf(':'));
			RESULT=new InstrLabel(sim_inst.machine,label);
		:}
    |
        SIZE_TYPE ID COMMA DOT MINUS ID eol
        {:
            /* Do not do anything... */
        :}
	;

exp	::=
		NUM:n
		{:
			RESULT=n;
		:}
	|	HEX:n
		{:
			RESULT=new TokenValue(n.toString(), n.line, n.pos);
		:}
	;
