package parse;

import java_cup.runtime.*;
import java.util.*;

import parse.TokenValue;

import machine.MachineState;

import instructions.*;

parser code {:

    protected static MachineState machine = null;//complete hack
    //hopefully it will work.

    public sim_inst(java_cup.runtime.Scanner lexer, MachineState machine)
    {
        this(lexer);
        this.machine = machine;
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        report_fatal_error("Fatal syntax error", cur_token);
    }
    
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        done_parsing();
        Symbol token = (Symbol)info;
        TokenValue tok = (TokenValue)token.value;
        throw new ParseException("Fatal parsing error", tok.line, tok.pos);
    }
    
    public void report_error(String message, Object info) {
        Symbol token = (Symbol)info;
        TokenValue tok = (TokenValue)token.value;
        System.err.println("[" + tok.line + "," + tok.pos + "] " 
                               + message + " at " + tok.toString() );
    }
:}

/* Symbols */
terminal EOL;
terminal ASSIGN, COMMA;
terminal TokenValue NUM, HEX, QSTRING;
terminal TokenValue DOT_FILE, DOT_GLOBAL, DOT_TEXT, DOT_TYPE, SIZE_TYPE, MINUS, DOT;
terminal TokenValue SP_L, SP_H;
terminal TokenValue REG, LABEL, GLOBAL, TYPE, ID;

non terminal TokenValue exp;
non terminal List<Instr> pgrm, instrs;
non terminal Instr instr;
non terminal header; 

/* AVR Functions */
terminal AVR_PUSH, AVR_POP, AVR_IN, AVR_LD, AVR_LDI, AVR_ADD, AVR_ADC, AVR_CALL, AVR_RET, AVR_AND, AVR_EOR, AVR_JMP, AVR_NEG, AVR_OR, AVR_CP, AVR_SUB, AVR_BREQ, AVR_BRLO;

/* Grammar */
start with pgrm;

pgrm	::=	header instrs:s
		{:
			RESULT=s;
		:}
	;

header	::=	DOT_FILE QSTRING EOL
		GLOBAL ASSIGN HEX EOL
		SP_H ASSIGN HEX EOL
		SP_L ASSIGN HEX EOL
		GLOBAL ASSIGN exp EOL
		GLOBAL ASSIGN exp EOL
		DOT_GLOBAL ID EOL
		DOT_GLOBAL ID EOL
		DOT_TEXT EOL
		DOT_GLOBAL ID EOL
		DOT_TYPE ID COMMA TYPE EOL
		LABEL EOL
		AVR_PUSH REG EOL
		AVR_PUSH REG EOL
		AVR_IN REG COMMA SP_L EOL
		AVR_IN REG COMMA SP_H EOL
		AVR_CALL ID EOL
		AVR_CALL ID EOL
		{:
		    RESULT=null;//empty state.
        :}
	;

instrs	::=	instr:t instrs:list
		{:
            list.add(0,t);
			RESULT=list;
		:}

        | /* epsilon */ 
        {:
            RESULT = new LinkedList<Instr>();
        :}
	;

instr	::=	AVR_PUSH REG:r EOL
		{:
			RESULT= new InstrPush(sim_inst.machine,Integer.parseInt(r.toString()));
		:}
	|	AVR_POP REG:r EOL 
		{:
			RESULT= new InstrPop(sim_inst.machine,Integer.parseInt(r.toString()));
		:}
	|	AVR_IN REG:r COMMA SP_L EOL 
		{:
			RESULT= new InstrIn(sim_inst.machine,Integer.parseInt(r.toString()),InstrInType.SPL);
		:}
	|	AVR_IN REG:r COMMA SP_H EOL 
		{:
			RESULT= new InstrIn(sim_inst.machine,Integer.parseInt(r.toString()),InstrInType.SPH);
		:}
	|	AVR_LD EOL 
		{:
			//RESULT= new InstrLD(sim_inst.machine);
		:}
	|	AVR_LDI REG:r COMMA exp:e EOL 
		{:
			RESULT= new InstrLDI(sim_inst.machine,Integer.parseInt(r.toString()),Integer.parseInt(e.toString()));
		:}
	|	AVR_ADD REG:r1 COMMA REG:r2 EOL 
		{:
			RESULT= new InstrAdd(sim_inst.machine,Integer.parseInt(r1.toString()),Integer.parseInt(r2.toString()));
		:}
	|	AVR_ADC REG:r1 COMMA REG:r2 EOL 
		{:
			RESULT= new InstrAdc(sim_inst.machine,Integer.parseInt(r1.toString()),Integer.parseInt(r2.toString()));
		:}
	|	AVR_CALL ID:l EOL 
		{:
			RESULT= new InstrCall(sim_inst.machine,l.toString());
		:}
	|	AVR_RET EOL 
		{:
			RESULT= new InstrRet(sim_inst.machine);
		:}
	|	AVR_AND REG:r1 COMMA REG:r2 EOL 
		{:
			RESULT= new InstrAnd(sim_inst.machine,Integer.parseInt(r1.toString()),Integer.parseInt(r2.toString()));
		:}
	|	AVR_EOR REG:r1 COMMA REG:r2 EOL 
		{:
			RESULT= new InstrEor(sim_inst.machine,Integer.parseInt(r1.toString()),Integer.parseInt(r2.toString()));
		:}
	|	AVR_JMP ID:l EOL 
		{:
			RESULT= new InstrJmp(sim_inst.machine,l.toString());
		:}
	|	AVR_NEG REG:r EOL 
		{:
			RESULT= new InstrNeg(sim_inst.machine,Integer.parseInt(r.toString()));
		:}
    |
        AVR_BREQ ID:l EOL
        {:
            RESULT= new InstrBREQ(sim_inst.machine,l.toString()); 
        :}
    |
        AVR_BRLO ID:l EOL
        {:
            RESULT= new InstrBRLO(sim_inst.machine,l.toString()); 
        :}
    |
        AVR_CP REG:r1 COMMA REG:r2 EOL
        {:
            RESULT= new InstrCP(sim_inst.machine,Integer.parseInt(r1.toString()),Integer.parseInt(r2.toString()));
        :}
	|	AVR_OR REG:r1 COMMA REG:r2 EOL 
		{:
			RESULT= new InstrOr(sim_inst.machine,Integer.parseInt(r1.toString()),Integer.parseInt(r2.toString()));
		:}
	|	LABEL:l | LABEL:l EOL 
		{:
            //Edit the label a bit.
            String label = l.toString();
            label = label.substring(0,label.indexOf(':'));
			RESULT=new InstrLabel(sim_inst.machine,label);
		:}
    |
        SIZE_TYPE ID COMMA DOT MINUS ID EOL
        {:
            /* Do not do anything... */
        :}
	;

exp	::=
		NUM:n
		{:
			RESULT=n;
		:}
	|	HEX:n
		{:
			RESULT=new TokenValue(n.toString(), n.line, n.pos);
		:}
	;
