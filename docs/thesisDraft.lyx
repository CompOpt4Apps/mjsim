#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
MeggyJava: Making the Compilers Course More Attractive to Undergraduate
 Students
\end_layout

\begin_layout Author
Ryan Moore
\end_layout

\begin_layout Date
November 5, 2010
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Interest in the Topic
\end_layout

\begin_layout Standard
Compiler construction is an important area in Computer Science.
 Compilers are software packages that will compile(reduce) a higher level
 programming language to a machine language which computers understand and
 can run.
 Compilers have a great impact on how fast a program can run.
 If a compiler is not designed well it can produce code that is slow or
 incorrect, which makes compiler construction an important topic.
 Unfortunately many undergraduate students do not find the area interesting
 due either to the large amount of programming involved, or because they
 do not see how the skills learned in compilers are relevant to software
 development in general.
 I myself was not originally attracted to the idea of writing compilers
 mostly due to how much programming would be required, but after my adviser
 and I had identified this project I signed up for the compiler course the
 next day and loved the course.
 From a purely theoretical and intellectual standpoint, I found writing
 compilers satisfying.
 It ties together a lot of theory with concrete examples as well as how
 good software engineering techniques can be used with actual Computer Science
 theory.
 It really makes all of the previous classes mean something, even the classes
 that you never thought would be useful outside of the classroom.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename meggyJr.jpg
	scale 60

\end_inset


\end_layout

\begin_layout Section*
Project Scope
\end_layout

\begin_layout Standard
To make compilers more interesting to undergraduate students I am going
 to modify the main project in the course so that instead of writing a compiler
 that generates MIPS assembly code the course will now write a compiler
 that generates AVR assembly code, which will run on the Evil Mad Scientist
 Laboratories Meggy Jr game platform.
 The Meggy Jr looks similar to a GameBoy handheld system but with a 8 by
 8 LED screen instead of a full screen.
 The reason for the switch is that currently when students generate MIPS
 assembly they can only run it inside of the MARS Simulator.
 The students do not see their code doing anything particularly interesting
 on an actual machine.
 By making the main project target a machine where they can run their code
 after generating it, and see it work, will make the course more interesting
 and attract more undergraduate students.
\end_layout

\begin_layout Section*
Tasks To Support Project
\end_layout

\begin_layout Standard
There are several major tasks that need to be completed to support the changes
 to the course project.
\end_layout

\begin_layout Enumerate
The first major task is to create a tool-chain, or build process, that students
 will use to compile their generated assembly code into an executable that
 will be uploaded to a Meggy Jr.
 This will include finding all the correct source files that target the
 Meggy Jr, as well as finding and installing a compiler that will assemble
 the generated assembly code into an executable.
 The final process is to then make it easy enough so that students can take
 their generated assembly and pass it into the tool-chain.
\end_layout

\begin_layout Enumerate
The next major task is to update the reference compiler that is used in
 the course to generate AVR assembly instead of MIPS assembly code.
 In addition to converting everything to AVR some new instructions will
 need to be added to the MiniJava language to support the new Meggy functions
 for editing the display state of the Meggy Jr as well as reading button
 presses from the Meggy Jr.
\end_layout

\begin_layout Enumerate
The last major task is to implement a simulator that will be used for grading
 as well as allowing students to debug the assembly code generated by their
 compiler before uploading it to the Meggy Jr device.
 The simulator will allow students to interactively step through their generated
 assembly code and watch to see what happens as each instruction is ran.
 This is the most important step because without this there is no way to
 accurately grade all of the student's compilers in a reasonable amount
 of time due to differences in the generated assembly.
 The simulator will allow for the generated assembly programs to be ran
 in a batch mode where the programs are ran to completion so that grading
 can be automated and the TA/Professor will not have to grade each generated
 assembly file by hand.
 This simulator will implement a subset of the AVR assembly such that students
 will be able to simulate what will happen on an actual device.
\end_layout

\begin_layout Section*
Steps Taken
\end_layout

\begin_layout Standard
In order to complete the project, it was split into multiple steps that
 would build on each other.
 In order to test that the compiler is working correctly I needed to have
 the build process complete and running.
 Following this was updating some of the basic examples in the reference
 compiler so that the simulator could have some example programs to execute.
 The final step was to make sure that each of the three steps works for
 the same input.
 In addition to each of the step I had to make sure that there were code
 examples that would work throughout each process.
 If there are not any code examples there would be no way to verify that
 any of the 3 steps were working correctly.
 I created code examples to figure out what instructions needed to be simulated
 in the simulator as well as to test the compiler to verify all the steps
 where working.
\end_layout

\begin_layout Subsection*
Build Process
\end_layout

\begin_layout Standard
Implementing the code that builds the AVR executable took a lot of investigating
 into using the Arduino IDE(Integrated Development Environment).
 The Arduino environment is an open source project that takes C/C++ code
 and will compile it down to the AVR assembly and build the executable for
 the Meggy Jr device, however trying to figure out how they do all of this
 is challenging.
 The reason it was so challenging was that the process that is used in the
 Arduino environment to compile and build everything was not documented.
 The only documentation that I could find on the build process was to enable
 verbose mode, which prints out extra information as it is building.
 I was able to use this verbose information to figure out the build process
 but I had to clear out the extra data and find the commands that were used.
\end_layout

\begin_layout Standard
Once I had all the commands documented I was then able to get the utilities
 that are used in the build process: the assembler, the device up-loader,
 and the libraries used by the MeggyJr.
 Getting these utilities was not  difficult but it did require me having
 to build many of the utilities from source code.
 Once the utilities were built I was able to write a program that takes
 in an AVR assembly file and builds the executable and then uploads it to
 a connected MeggyJr.
 Once the build process was figured out I was able to build some example
 code files to see how the gcc compiler would compile certain code snippets
 so that I could model the reference compiler off of it.
\end_layout

\begin_layout Subsection*
Reference Compiler
\end_layout

\begin_layout Standard
Updating the reference compiler has proved to not be the most important
 area of the project.
 The reason for this is that without the other two portions of the project
 done we will not have a way to run the programs once they have been compiled,
 or will be have a way to grade the compilers that the students will write.
\end_layout

\begin_layout Standard
Most of the work in the compiler has been updating the code gen pass to
 change it from MIPS assembly to AVR assembly.
 Many of the changes are simple 1-to-1 changes.
 For instance with the LDI(LoaD Immediate) instruction I only had to change
 the register to say r23 instead of $23.
 Another thing that I had to do in order to change the reference compiler
 was to remove the logic that recorded the return address in the frame.
 Generally in most instruction sets you have to store the return address
 for a function call as part of the prologue to that function so that you
 can get back to where you were when you issue a ret(Return) instruction.
 In MIPS you had to worry about this and had to copy $ra onto the stack.
 In AVR however the instruction set does this for you.
 The return address is not a register like it is in MIPS, it is actually
 located in the IO Register space and is taken care of for you when you
 issue the call instruction and the ret instruction.
\end_layout

\begin_layout Standard
Another thing that the AVR instruction set takes care of is incrementing
 the stack pointer after data is added or removed from the stack.
 In MIPS in order to add something to the stack you had to first decrement
 the stack pointer and then store the data to memory at the stack pointer.
 The same goes for removing something from the stack, increment the stack
 pointer and the data is effectively removed.
 In AVR however there are some special instructions that take care of this
 already.
 They are PUSH and POP.
 The PUSH command will decrement the stack pointer and then store any data
 that is in the register followed the push command.
 The POP command behaves in a similar manor.
 It will copy the value at the stack pointer into the register and then
 increment the stack pointer.
 Another difference between these two instruction sets is that the stack
 pointer is not a register in the register file, it is actually stored in
 the IO register space.
\end_layout

\begin_layout Subsection*
Simulator
\end_layout

\begin_layout Standard
The simulator has proved to be the most important and time consuming portion
 of the whole project.
 The simulator had to be designed from the ground up by myself with some
 advisement from Dr.
 Strout.
 We were not able to base the simulator off of anything that already exists
 because we are having to not only simulate the AVR instruction set but
 to also simulate how the MeggyJr will behave when we make calls to the
 MeggyJr library.
\end_layout

\begin_layout Standard
The first step I took when designing the simulator was figuring out what
 exact functionality we want, for example what instructions to simulate
 and how we want the simulator to behave for grading.
 For grading we want the simulator to run in batch mode.
 Batch mode will run through an entire program to completion.
 As it runs it will output text stating what instruction the simulator is
 running that affects the MeggyJr state, so when the program executes an
 instruction that changes a color pixel the simulator will print out the
 pixel and the color.
\end_layout

\begin_layout Standard
I also had to figure out the best way to organize the instructions and how
 to implement the AVR machine so that the instructions can change the AVR
 machine without repeating the same code over and over again.
 To accomplish this I decided to create an Class called MachineState which
 will hold all of the machine information: the instructions, the registers,
 the memory space, etc.
 I then created a Class for every instruction.
 Each of these classes extends from the same base class allowing for the
 code that implements updating the MachineState to be shared amongst all
 of the different instructions.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename simulator.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
Each of the Instr classes has an UpdateEvent assosiated with it when the
 Instr gets constructed.
 This allows for each Instr class to customize the data that it sets to
 update the MachineState object.
 In the Instr base class there is an executeWrapper function that will call
 the execute function which each Instr class has to implement.
 This method will then send the UpdateEvent to the MachineState object.
 If you look at the MachineState methods there are no setter methods.
 The only way to update the MachineState is through the use of the UpdateEvent
 object.
 This allows for  explicit control over how the MachineState gets updated
 and also means that in each Instr subclass inside of the execute method
 the writer of the subclass has to only update the information in the UpdateEven
t object but does not have to remember to send the UpdateEvent to the MachineSta
te.
\end_layout

\begin_layout Standard
I made a design decision to not check to see if a label exists in the call
 instruction.
 The reason for this is that it would require another loop over all of the
 instructions to determine if the label exists, but we can at run-time determine
 this instead.
 I made this decision to make the parsing simpler and require fewer steps.
 To implement this checking at run-time proved to be easy and whenever there
 is a run-time error the error is reported with the Label name and execution
 ends.
\end_layout

\begin_layout Standard
Another requirement for the simulator is to simulate function calls that
 are implemented in the MeggyJr library and some of the AVR std C library.
 We need to simulate these functions so that students will be able to see
 what the actual hardware will do.
 So in the case where we want to turn on a single LED on the LED screen
 we need to call the setPix function in the MeggyJr library, which will
 set and turn on the LED in the LED screen.
 If we do not simulate these functions then the simulator will throw a run-time
 error saying that the function does not exist, so it is important that
 we add additional logic into the machine so to record all of the pre-defined
 functions.
 This changes how the MachineState looks.
 It is now also managing all of the pre-defined functions.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename simulatorFunctions.png
	scale 35

\end_inset


\end_layout

\begin_layout Standard
The picture of the simulator now has in addition to managing the machine
 state, it also records all of the function calls.
 Generally I would separate out this functionality into separate classes
 but the reason I did not here is that all of the instructions when they
 are read in include not only the individual instructions but include all
 of the function calls.
 It made sense to include the functions into the MachineState class since
 it already keeps track of the address space where all the instructions
 are stored.
\end_layout

\begin_layout Standard
Once the instructions have been read into the MachineState object then it
 is just a matter of calling executeInstruction, which will then execute
 the every first instruction and update the MachineState.
 This makes it easy to extend how the MachineState will execute.
 It can either run in a while loop until there are no more instructions
 to run to make it run in batch mode, or it can be ran to include stop points
 so students can pause the execution and probe the MachineState to see if
 their assembly is doing what they expect.
\end_layout

\begin_layout Section*
Future Work
\end_layout

\begin_layout Standard
In addition to all the functionally that has been listed above I plan to
 add some additional functionally to make using the simulator easier for
 the students in the class.
 Currently there is lots of logging statements that can be printed out and
 modified in the jar file, but if something is not working correctly the
 students will need another way to debug to see if their assembly is doing
 what they expect it to do.
 
\end_layout

\begin_layout Standard
To aid students in this I plan to add a GUI interface where students will
 be able to inspect the memory space: the heap, the stack, and the program
 space.
 This will allow students to see the side effects of the different instructions
 on the MachineState.
 I plan to model some of this off of the behavior seen in the MARS simulator.
 The MARS simulator allows you to inspect different parts of the memory
 space, and the registers.
 It has additional features and functionality that I do not plan to add.
 These sorts of features are mostly customization and code editing features.
 The goal will be to just allow students to see what their code is doing
 step by step.
\end_layout

\begin_layout Section*
Wrap Up
\end_layout

\begin_layout Standard
The project has been a great learning experience tying together many different
 aspects of Computer Science.
 I have learned many new things about assembly languages and machine architectur
es, as well as understanding some of the design decisions that went into
 the assembly languages due to implementing the instructions in the simulator.
 
\end_layout

\begin_layout Standard
The simulator has been the most important and interesting part of the project.
 Without it making the transition to using the MeggyJr platform could not
 happen.
 I feel that the class will be more attractive to other undergraduate students
 based off of the feedback I have received from my peers in my other classes.
 The effort put into this project I feel will make the compiler course stronger
 and also make the students that take the class stronger programmers.
 I know it has made me a stronger programmer.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Resources
\end_layout

\begin_layout Itemize
Michelle Strout - Thesis Adviser and Compiler Professor
\end_layout

\begin_layout Itemize
Current CS453 Website - Outline of Compiler Development Iterations - http://www.c
s.colostate.edu/~cs453
\end_layout

\begin_layout Itemize
MiniJava Grammar Web page - Description of the MiniJava Language - http://www.cam
bridge.org/resources/052182060X/MCIIJ2e/grammar.htm
\end_layout

\begin_layout Itemize
ATmega328p Feature Document - Outline of the AVR Instruction Set and the
 Major Features of the Atmega328p processor - http://www.atmel.com/dyn/resources/p
rod_documents/8271S.pdf
\end_layout

\begin_layout Itemize
ATmega328p In-depth Feature Document - Full Description of Instruction Set
 and Processor Design - http://www.atmel.com/dyn/resources/prod_documents/doc8271.p
df
\end_layout

\begin_layout Itemize
Meggy Jr Web page - Description of Meggy Jr - http://www.evilmadscientist.com/arti
cle.php/meggyjr
\end_layout

\end_body
\end_document
